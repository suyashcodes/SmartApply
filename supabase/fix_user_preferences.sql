-- Fix for User Preference Embedding Issues
-- Run this in your Supabase SQL Editor

-- 1. Update the personalized recommendations function to handle missing preferences
CREATE OR REPLACE FUNCTION get_personalized_recommendations(
  user_id_param uuid,
  recommendation_count int DEFAULT 15
)
RETURNS TABLE (
  job_id uuid,
  title text,
  company text,
  location text,
  experience_level text,
  employment_type text,
  industry text,
  preference_similarity float,
  job_match_score jsonb,
  recommendation_score float
)
LANGUAGE plpgsql
AS $$
DECLARE
  user_embedding vector(1536);
BEGIN
  -- Get user preference embedding
  SELECT preference_embedding INTO user_embedding 
  FROM user_profiles 
  WHERE user_id = user_id_param;
  
  -- If no preference embedding exists, return jobs based on match score only
  IF user_embedding IS NULL THEN
    RETURN QUERY
    SELECT 
      j.id as job_id,
      j.title,
      j.company,
      j.location,
      j.experience_level,
      j.employment_type,
      j.industry,
      0.5::float as preference_similarity, -- Default similarity
      calculate_advanced_job_match_score(user_id_param, j.id) as job_match_score,
      (calculate_advanced_job_match_score(user_id_param, j.id)->>'overall_score')::float / 100 as recommendation_score
    FROM jobs j
    WHERE 
      j.is_active = true
      AND j.embedding IS NOT NULL
    ORDER BY recommendation_score DESC
    LIMIT recommendation_count;
    RETURN;
  END IF;
  
  -- Original logic for users with preference embeddings
  RETURN QUERY
  WITH preference_matches AS (
    SELECT 
      j.*,
      1 - (j.embedding <=> user_embedding) as pref_similarity
    FROM jobs j
    WHERE 
      j.is_active = true
      AND j.embedding IS NOT NULL
  ),
  scored_recommendations AS (
    SELECT 
      pm.*,
      calculate_advanced_job_match_score(user_id_param, pm.id) as match_score,
      (pm.pref_similarity * 0.6 + (calculate_advanced_job_match_score(user_id_param, pm.id)->>'overall_score')::numeric / 100 * 0.4) as rec_score
    FROM preference_matches pm
  )
  SELECT 
    sr.id as job_id,
    sr.title,
    sr.company,
    sr.location,
    sr.experience_level,
    sr.employment_type,
    sr.industry,
    sr.pref_similarity as preference_similarity,
    sr.match_score as job_match_score,
    sr.rec_score as recommendation_score
  FROM scored_recommendations sr
  ORDER BY sr.rec_score DESC
  LIMIT recommendation_count;
END;
$$;

-- 2. Create a function to initialize user preferences with default values
CREATE OR REPLACE FUNCTION initialize_user_preferences(
  user_id_param uuid,
  user_skills text[] DEFAULT ARRAY[]::text[],
  preferred_roles text[] DEFAULT ARRAY[]::text[],
  preferred_industries text[] DEFAULT ARRAY[]::text[]
)
RETURNS boolean
LANGUAGE plpgsql
AS $$
DECLARE
  preference_text_param text;
BEGIN
  -- Create a default preference text from user data
  SELECT 
    COALESCE(up.bio, '') || ' ' || 
    COALESCE(array_to_string(user_skills, ' '), '') || ' ' ||
    COALESCE(array_to_string(preferred_roles, ' '), '') || ' ' ||
    COALESCE(array_to_string(preferred_industries, ' '), '') || ' ' ||
    'seeking opportunities career growth development'
  INTO preference_text_param
  FROM user_profiles up
  WHERE up.user_id = user_id_param;
  
  -- Update the preference text (embedding will be generated by the frontend)
  UPDATE user_profiles 
  SET preference_text = COALESCE(preference_text_param, 'seeking career opportunities growth development')
  WHERE user_id = user_id_param;
  
  RETURN FOUND;
END;
$$;

-- 3. Create a simple fallback search function for when semantic search fails
CREATE OR REPLACE FUNCTION fallback_job_search(
  user_id_param uuid DEFAULT NULL,
  match_count int DEFAULT 20,
  filter_experience_level text DEFAULT NULL,
  filter_employment_type text DEFAULT NULL,
  filter_industry text DEFAULT NULL,
  filter_location text DEFAULT NULL
)
RETURNS TABLE (
  job_id uuid,
  title text,
  company text,
  location text,
  experience_level text,
  employment_type text,
  industry text,
  description text,
  salary_min numeric,
  salary_max numeric,
  currency text,
  work_type text,
  posted_date timestamp,
  is_active boolean,
  semantic_similarity float,
  job_match_score jsonb
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    j.id as job_id,
    j.title,
    j.company,
    j.location,
    j.experience_level,
    j.employment_type,
    j.industry,
    j.description,
    j.salary_min,
    j.salary_max,
    j.currency,
    j.work_type,
    j.posted_date,
    j.is_active,
    0.7::float as semantic_similarity, -- Default similarity
    CASE 
      WHEN user_id_param IS NOT NULL THEN 
        calculate_advanced_job_match_score(user_id_param, j.id)
      ELSE 
        jsonb_build_object('overall_score', 75, 'skills_match', 70, 'experience_match', 75, 'industry_match', 80, 'location_match', 75, 'title_match', 70)
    END as job_match_score
  FROM jobs j
  WHERE 
    j.is_active = true
    AND (filter_experience_level IS NULL OR j.experience_level = filter_experience_level)
    AND (filter_employment_type IS NULL OR j.employment_type = filter_employment_type)
    AND (filter_industry IS NULL OR j.industry = filter_industry)
    AND (filter_location IS NULL OR j.location ILIKE '%' || filter_location || '%')
  ORDER BY j.posted_date DESC
  LIMIT match_count;
END;
$$;
